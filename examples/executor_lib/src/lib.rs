use std::{
    fmt::{Debug, Formatter},
    ops::Deref,
    sync::{Arc, OnceLock},
};

use policy_carrying_data::DataFrame;
use policy_core::{
    error::{PolicyCarryingError, PolicyCarryingResult},
    types::{ExecutorType, FunctionArguments},
};
use policy_execution::{
    executor::{
        evaluate_physical_expr_vec, filter::FilterExec, projection::ProjectionExec,
        scan::DataFrameExec, ExecutionState, Executor, PhysicalExecutor,
    },
    trace,
};

// TODO: A demo. In productive platforms, this data should be fetched from the persistent layer and should be
// stored in encrypted form to ensure optimal security.
static DATA: OnceLock<Arc<DataFrame>> = OnceLock::new();

/// From this timepoint, we can load the data into the memory!
#[no_mangle]
extern "C" fn on_load(args: *const u8, args_len: usize) -> i32 {
    // Deserialize the arguments.
    let args = unsafe {
        let args = std::slice::from_raw_parts(args, args_len);
        std::str::from_utf8_unchecked(args)
    };
    let args = match serde_json::from_str::<FunctionArguments>(args) {
        Ok(args) => args,
        Err(_) => return -2,
    };

    let df = match DataFrame::try_from(args) {
        Ok(df) => Arc::new(df),
        // TODO: convert Result to error code.
        Err(_) => return -1,
    };

    let _ = DATA.set(df);

    0
}

#[no_mangle]
extern "C" fn on_unload(_args: *const u8, _args_len: usize) -> i32 {
    0
}

#[no_mangle]
extern "C" fn create_executor(
    executor_type: u64,
    args: *const u8,
    args_len: usize,
    p_executor: *mut usize,
) -> i32 {
    // Deserialize the arguments.
    let args = unsafe {
        let args = std::slice::from_raw_parts(args, args_len);
        std::str::from_utf8_unchecked(args)
    };
    let args = match serde_json::from_str::<FunctionArguments>(args) {
        Ok(args) => args,
        Err(_) => return -2,
    };

    let executor_type = unsafe { std::mem::transmute::<u64, ExecutorType>(executor_type) };
    let executor: Executor = match executor_type {
        ExecutorType::DataframeScan => match DataFrameExec::try_from(args) {
            Ok(mut exec) => match DATA.get() {
                Some(df) => {
                    exec.df.replace(df.clone());
                    Box::new(MyDataFrameScanExec(exec))
                }
                None => return -3,
            },
            Err(_) => return -2,
        },
        ExecutorType::Projection => match ProjectionExec::try_from(args) {
            Ok(exec) => Box::new(MyProjectionExec(exec)),
            Err(_) => return -2,
        },
        ExecutorType::Filter => match FilterExec::try_from(args) {
            Ok(exec) => Box::new(MyFilterExec(exec)),
            Err(_) => return -2,
        },
        // Not implemented.
        _ => return -1,
    };

    let executor = Box::new(executor);
    unsafe {
        // Leak the box and transfer the ownership to the Rust caller.
        *p_executor = Box::into_raw(executor) as usize;
    }

    0
}

// ============= Below should be automatically generated by the policy generator ============= //
pub struct MyDataFrameScanExec(DataFrameExec);
pub struct MyProjectionExec(ProjectionExec);
pub struct MyFilterExec(FilterExec);

impl Debug for MyDataFrameScanExec {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "MyDataFrameScanExec")
    }
}

impl Debug for MyProjectionExec {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "MyProjectionExec")
    }
}

impl Debug for MyFilterExec {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "MyFilterExec")
    }
}

impl PhysicalExecutor for MyDataFrameScanExec {
    fn execute(&mut self, state: &ExecutionState) -> PolicyCarryingResult<DataFrame> {
        trace!(state, "MyDataFrameScanExec");

        // Check if the dataframe is being used or referenced by other executors.
        // If there is no other pointers, we can modify the dataframe in-place. Otherwise, we need
        // to make a clone.
        let df = std::mem::take(&mut self.0.df);
        let mut df = Arc::try_unwrap(df.ok_or(PolicyCarryingError::OperationNotAllowed(
            "data frame is not loaded".into(),
        ))?)
        .unwrap_or_else(|df| df.deref().clone());

        // Apply projection and selection at first to reduce the amount of data that should be returned.
        if let Some(projection) = self.0.projection.as_ref() {
            df = df.projection(projection)?;
        }

        // Then apply filter.
        if let Some(selection) = self.0.selection.as_ref() {
            let selection = selection.evaluate(&df, state)?;

            if self.0.predicate_has_windows {
                return Err(PolicyCarryingError::OperationNotSupported);
            }

            df = df.filter(selection.as_boolean()?)?;
        }

        Ok(df)
    }
}

impl PhysicalExecutor for MyProjectionExec {
    fn execute(&mut self, state: &ExecutionState) -> PolicyCarryingResult<DataFrame> {
        trace!(state, "MyProjectionExec");

        let df = self.0.input.execute(state)?;
        evaluate_physical_expr_vec(&df, self.0.expr.as_ref(), state)
    }
}

impl PhysicalExecutor for MyFilterExec {
    fn execute(&mut self, state: &ExecutionState) -> PolicyCarryingResult<DataFrame> {
        trace!(state, "MyFilterExec");

        let df = self.0.input.execute(state)?;
        let filtered = self.0.predicate.evaluate(&df, state)?;
        let boolean_array = filtered.as_boolean()?;

        df.filter(&boolean_array)
    }
}
