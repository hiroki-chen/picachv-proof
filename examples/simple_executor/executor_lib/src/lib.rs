use std::{
    any::Any,
    fmt::{Debug, Formatter},
    sync::{Arc, OnceLock},
};

use policy_carrying_data::DataFrame;
use policy_core::{
    error::{PolicyCarryingError, PolicyCarryingResult, StatusCode},
    pcd_ffi_try,
    types::*,
};
use policy_execution::executor::{
    distinct::DistinctExec, filter::FilterExec, groupby_partitioned::PartitionGroupByExec,
    projection::ProjectionExec, scan::DataFrameExec, ExecutionState, Executor, PhysicalExecutor,
};
use policy_privacy::PrivacyMananger;
use policy_utils::args_from_raw;

// A demo. In productive platforms, this data should be fetched from the persistent layer and should be
// stored in encrypted form to ensure optimal security.
static DATA: OnceLock<Arc<DataFrame>> = OnceLock::new();
/// A privacy manager.
static PRIVACY_MANAGER: OnceLock<Arc<PrivacyMananger>> = OnceLock::new();

/// Ensuring the version string matches; this content is read from build script.
static RUSTC_VERSION: &str = env!("RUSTC_VERSION");

/// Gets the version string as a pointer in C-style.
#[no_mangle]
extern "C" fn rustc_version(buf: *mut u8, len: *mut usize) {
    unsafe {
        std::ptr::copy_nonoverlapping(RUSTC_VERSION.as_ptr(), buf, RUSTC_VERSION.len());
        *len = RUSTC_VERSION.len();
    }
}

/// Some prelimiary tasks to be done.
#[no_mangle]
extern "C" fn on_load(_args: *const u8, _args_len: usize) -> StatusCode {
    StatusCode::Ok
}

#[no_mangle]
extern "C" fn load_data(args: *const u8, args_len: usize) -> StatusCode {
    let args = pcd_ffi_try!(args_from_raw(args, args_len));

    let df = pcd_ffi_try!(DataFrame::try_from(args));
    pcd_ffi_try!(DATA
        .set(df.into())
        .map_err(|_| PolicyCarryingError::Unknown));

    StatusCode::Ok
}

#[no_mangle]
extern "C" fn on_unload(_args: *const u8, _args_len: usize) -> StatusCode {
    StatusCode::Ok
}

#[no_mangle]
extern "C" fn create_executor(
    args: *const u8,
    args_len: usize,
    p_executor: *mut OpaquePtr,
) -> StatusCode {
    let args = pcd_ffi_try!(args_from_raw(args, args_len));

    let executor_type = pcd_ffi_try!(pcd_ffi_try!(args.get_and_apply(
        "executor_type",
        |ty: String| {
            serde_json::from_str::<ExecutorType>(&ty)
                .map_err(|e| PolicyCarryingError::SerializeError(e.to_string()))
        }
    )));

    let executor: Executor = match executor_type {
        ExecutorType::DataframeScan => {
            let mut exec = pcd_ffi_try!(DataFrameExec::try_from(args));
            match DATA.get() {
                Some(df) => {
                    exec.df.replace(df.clone());
                    Box::new(MyDataFrameScanExec(exec))
                }
                None => return StatusCode::NotLoaded,
            }
        }
        ExecutorType::Projection => Box::new(MyProjectionExec(pcd_ffi_try!(
            ProjectionExec::try_from(args)
        ))),
        ExecutorType::Filter => Box::new(MyFilterExec(pcd_ffi_try!(FilterExec::try_from(args)))),
        ExecutorType::PartitionGroupBy => Box::new(MyPartitionGroupByExec(pcd_ffi_try!(
            PartitionGroupByExec::try_from(args)
        ))),
        ExecutorType::Distinct => {
            Box::new(MyDistinctExec(pcd_ffi_try!(DistinctExec::try_from(args))))
        }

        // Not implemented.
        _ => return StatusCode::Unsupported,
    };

    let executor = Box::new(executor);
    unsafe {
        // Leak the box and transfer the ownership to the Rust caller.
        *p_executor = Box::into_raw(executor) as _;
    }

    StatusCode::Ok
}

#[no_mangle]
extern "C" fn execute(executor: OpaquePtr, df_ptr: *mut u8, df_len: *mut usize) -> StatusCode {
    let mut executor = unsafe { Box::from_raw(executor as *mut Executor) };

    let df_str = pcd_ffi_try!(executor.execute(&mut ExecutionState::default())).to_json();
    unsafe {
        std::ptr::copy_nonoverlapping(df_str.as_ptr(), df_ptr, df_str.len());
        *df_len = df_str.len();
    }
    StatusCode::Ok
}

// ============= Below should be automatically generated by the policy generator ============= //
#[derive(Clone)]
pub struct MyDataFrameScanExec(DataFrameExec);
#[derive(Clone)]
pub struct MyProjectionExec(ProjectionExec);
#[derive(Clone)]
pub struct MyFilterExec(FilterExec);
#[derive(Clone)]
pub struct MyPartitionGroupByExec(PartitionGroupByExec);
#[derive(Clone)]
pub struct MyDistinctExec(DistinctExec);

impl Debug for MyDataFrameScanExec {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "MyDataFrameScanExec")
    }
}

impl Debug for MyProjectionExec {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "MyProjectionExec")
    }
}

impl Debug for MyFilterExec {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "MyFilterExec")
    }
}

impl Debug for MyPartitionGroupByExec {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "MyPartitionGroupByExec")
    }
}

impl Debug for MyDistinctExec {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "MyDistinctExec")
    }
}

impl PhysicalExecutor for MyDataFrameScanExec {
    fn execute(&mut self, state: &ExecutionState) -> PolicyCarryingResult<DataFrame> {
        self.0.execute(state)
    }

    fn as_any(&self) -> &dyn Any {
        self
    }

    fn clone_box(&self) -> Executor {
        Box::new(self.clone())
    }
}

impl PhysicalExecutor for MyProjectionExec {
    fn execute(&mut self, state: &ExecutionState) -> PolicyCarryingResult<DataFrame> {
        self.0.execute(state)
    }

    fn as_any(&self) -> &dyn Any {
        self
    }

    fn clone_box(&self) -> Executor {
        Box::new(self.clone())
    }
}

impl PhysicalExecutor for MyFilterExec {
    fn execute(&mut self, state: &ExecutionState) -> PolicyCarryingResult<DataFrame> {
        self.0.execute(state)
    }

    fn as_any(&self) -> &dyn Any {
        self
    }

    fn clone_box(&self) -> Executor {
        Box::new(self.clone())
    }
}

impl PhysicalExecutor for MyPartitionGroupByExec {
    fn execute(&mut self, state: &ExecutionState) -> PolicyCarryingResult<DataFrame> {
        self.0.execute(state)
    }

    fn as_any(&self) -> &dyn Any {
        self
    }

    fn clone_box(&self) -> Executor {
        Box::new(self.clone())
    }
}

impl PhysicalExecutor for MyDistinctExec {
    fn execute(&mut self, state: &ExecutionState) -> PolicyCarryingResult<DataFrame> {
        self.0.execute(state)
    }

    fn as_any(&self) -> &dyn Any {
        self
    }

    fn clone_box(&self) -> Executor {
        Box::new(self.clone())
    }
}
