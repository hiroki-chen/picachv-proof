# A tempted version of the policy specification language.
# We have two goals:
# 1. Ease of use: the grammar should not be too confusing.
# 2. Expressiveness: our policy should be able to expressive most privacy policies.
#
# To evaluate the usability of the policy language, we can conduct a user study involving several participants.

# Define a schema of the dataframe of a demo hospital data.
let hospital_data: Schema = {
  name: String,
  age: u8,
  SSN: String,
};

# Specify a policy for advertisement purposes.
let advertisement: Policy = {
  deny SSN except {
    apply(redact([-4:]))
  };

  deny age except {
    # You can only access ages in the range of [18, 80]
    (filter with (18 <= age and age <= 80))
      and
    # You must also generalize the data to prevent re-identification risks.
    (apply with generalization(>= 20))
      or
    # Age should be aggregated using the following four techniques.
    (aggregate with min or max or sum or avg)
      and
    # Differential privacy must be applied whose privacy budget is 1.0.
    (privacy with (differential_privacy with (1.0, 0.01)))
  };
                                                    
  deny [age, SSN] all;
};


# The most natural idea of fulfilling the enforcement of privacy policies would be to
# give the formal semantics of the relational algebra in which each operator would have
# the "same" working logic for all policies and data schema.
#
# We want to instead seek another approach for this issue by automatic generation of
# privacy policy compliant operators (some sort of code generation, so to speak), which
# serve as addtional operators in the query plan as some sort of "instrumented" nodes.
# 
# This would enjoy the following benefits.
# 1. Policy specific;
# 2. Reduce the code that should be checked;
# 3. 

# let df = df.lazy().select(["age", "ssn"])