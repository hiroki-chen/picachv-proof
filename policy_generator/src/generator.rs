use std::{collections::HashMap, fs, path::PathBuf};

use codegen::{Field, Scope};
use policy_core::{
    ast::{Clause, Policy},
    error::{PolicyCarryingError, PolicyCarryingResult},
};

static FFI_TEMPLATE: &str = include_str!("../templates/ld.rstp");
static BUILD_TEMPLATE: &str = include_str!("../templates/build.rstp");

/// Taking as input a policy struct [`Policy`] and an output file path, this function generates
/// the corresponding API set in the Rust source code for the policy language. This Rust source
/// code can be further compiled with the rustc compiler and be built to the dynamic module, if
/// needed.
pub fn codegen_output<P: Into<PathBuf>>(
    policy: Policy,
    output_file: P,
    output_build: P,
) -> PolicyCarryingResult<()> {
    let code = generate(policy)?;

    fs::write(output_file.into(), code.as_bytes())
        .map_err(|e| PolicyCarryingError::FsError(e.to_string()))?;
    fs::write(output_build.into(), BUILD_TEMPLATE)
        .map_err(|e| PolicyCarryingError::FsError(e.to_string()))
}

pub fn generate(policy: Policy) -> PolicyCarryingResult<String> {
    log::info!("generating API code for\n{policy:#?}");
    let mut scope = Scope::new();

    generate_imports(&mut scope)?;
    generate_auxiliary(&mut scope)?;
    generate_struct(&mut scope, policy)?;

    Ok(scope.to_string())
}

/// Generates necessary dependencies.
fn generate_imports(scope: &mut Scope) -> PolicyCarryingResult<()> {
    scope.import("policy_core::error", "PolicyCarryingError");
    scope.import("policy_core::error", "PolicyCarryingResult");
    scope.import("policy_core::data_type", "DataType");
    scope.import("std::pin", "Pin");
    scope.import("std::sync", "Arc");
    scope.import("policy_carrying_data::api", "ApiRequest");
    scope.import("policy_carrying_data::api", "PolicyApiSet");
    scope.import("policy_carrying_data", "DataFrame");

    Ok(())
}

/// Generates the struct on which the `PolicyApiSet` trait can be implemented. To faciliate the
/// procedural macro to generate the expanded Rust code, the struct generated by this function
/// will include meaningful annotations.
fn generate_struct(scope: &mut Scope, policy: Policy) -> PolicyCarryingResult<()> {
    let name = policy.name();

    scope.raw(format!("static PLUGIN_NAME: &str = \"{}\";", name));
    let data_struct = scope
        .new_struct(name)
        .vis("pub")
        .attr("policy_carrying")
        .derive("Clone, Debug")
        .repr("C");

    // Construct a lookup map.
    let mut fields = policy
        .schema()
        .into_iter()
        .map(|(column, ty)| (column.clone(), Field::new(column, ty.to_qualified_str())))
        .collect::<HashMap<_, _>>();

    generate_annotations(&mut fields, policy.clause())?;

    // TODO: How to describe the cross-column policies using annotations?
    fields.into_values().for_each(|field| {
        data_struct.push_field(field);
    });

    Ok(())
}

/// Generates the policy-related procedural macro annotations on the struct's fields.
fn generate_annotations(
    fields: &mut HashMap<String, Field>,
    clauses: &[Clause],
) -> PolicyCarryingResult<()> {
    for clause in clauses {
        match clause {
            Clause::Allow {
                attribute_list,
                scheme,
            } => {
                // single-column or multi-column?
                match attribute_list.len() {
                    // Empty => just ignore it.
                    0 => continue,
                    // Single-column policy control.
                    1 => (),
                    // Multi-column policy control.
                    len => (),
                }
            }
            Clause::Deny(attribute_list) => {}
        }
    }

    Ok(())
}

/// Generates some auxiliary rust code including some external FFI interfaces.
fn generate_auxiliary(scope: &mut Scope) -> PolicyCarryingResult<()> {
    scope.raw(FFI_TEMPLATE.to_string());

    Ok(())
}
